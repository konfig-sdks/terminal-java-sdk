/*
 * Terminal API
 * Terminal is a unified API that makes it easy to integrate with the leading telematics service providers.  Contact Support:  Name: Terminal  Email: connect@withterminal.com
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.api;

import com.konfigthis.client.ApiCallback;
import com.konfigthis.client.ApiClient;
import com.konfigthis.client.ApiException;
import com.konfigthis.client.ApiResponse;
import com.konfigthis.client.Configuration;
import com.konfigthis.client.Pair;
import com.konfigthis.client.ProgressRequestBody;
import com.konfigthis.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;



import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class IssuesApiGenerated {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public IssuesApiGenerated() throws IllegalArgumentException {
        this(Configuration.getDefaultApiClient());
    }

    public IssuesApiGenerated(ApiClient apiClient) throws IllegalArgumentException {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    private okhttp3.Call listObservedEventsCall(String limit, String cursor, String lastReportedAfter, String lastReportedBefore, String expand, String connectionId, String errorCode, String status, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/issues";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (limit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("limit", limit));
        }

        if (cursor != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("cursor", cursor));
        }

        if (lastReportedAfter != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lastReportedAfter", lastReportedAfter));
        }

        if (lastReportedBefore != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("lastReportedBefore", lastReportedBefore));
        }

        if (expand != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("expand", expand));
        }

        if (connectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("connectionId", connectionId));
        }

        if (errorCode != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("errorCode", errorCode));
        }

        if (status != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("status", status));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call listObservedEventsValidateBeforeCall(String limit, String cursor, String lastReportedAfter, String lastReportedBefore, String expand, String connectionId, String errorCode, String status, final ApiCallback _callback) throws ApiException {
        return listObservedEventsCall(limit, cursor, lastReportedAfter, lastReportedBefore, expand, connectionId, errorCode, status, _callback);

    }


    private ApiResponse<Void> listObservedEventsWithHttpInfo(String limit, String cursor, String lastReportedAfter, String lastReportedBefore, String expand, String connectionId, String errorCode, String status) throws ApiException {
        okhttp3.Call localVarCall = listObservedEventsValidateBeforeCall(limit, cursor, lastReportedAfter, lastReportedBefore, expand, connectionId, errorCode, status, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call listObservedEventsAsync(String limit, String cursor, String lastReportedAfter, String lastReportedBefore, String expand, String connectionId, String errorCode, String status, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = listObservedEventsValidateBeforeCall(limit, cursor, lastReportedAfter, lastReportedBefore, expand, connectionId, errorCode, status, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class ListObservedEventsRequestBuilder {
        private String limit;
        private String cursor;
        private String lastReportedAfter;
        private String lastReportedBefore;
        private String expand;
        private String connectionId;
        private String errorCode;
        private String status;

        private ListObservedEventsRequestBuilder() {
        }

        /**
         * Set limit
         * @param limit The maximum number of results to return in a page. (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder limit(String limit) {
            this.limit = limit;
            return this;
        }
        
        /**
         * Set cursor
         * @param cursor Pagination cursor to start requests from (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder cursor(String cursor) {
            this.cursor = cursor;
            return this;
        }
        
        /**
         * Set lastReportedAfter
         * @param lastReportedAfter Timestamp to start when the issue was last observed (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder lastReportedAfter(String lastReportedAfter) {
            this.lastReportedAfter = lastReportedAfter;
            return this;
        }
        
        /**
         * Set lastReportedBefore
         * @param lastReportedBefore Timestamp to end when the issue was last observed (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder lastReportedBefore(String lastReportedBefore) {
            this.lastReportedBefore = lastReportedBefore;
            return this;
        }
        
        /**
         * Set expand
         * @param expand Expand related resources to see all details (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder expand(String expand) {
            this.expand = expand;
            return this;
        }
        
        /**
         * Set connectionId
         * @param connectionId Filter issues to a specific connection (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder connectionId(String connectionId) {
            this.connectionId = connectionId;
            return this;
        }
        
        /**
         * Set errorCode
         * @param errorCode Filter issues to a specific error code (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder errorCode(String errorCode) {
            this.errorCode = errorCode;
            return this;
        }
        
        /**
         * Set status
         * @param status Filter issues to a specific status (optional)
         * @return ListObservedEventsRequestBuilder
         */
        public ListObservedEventsRequestBuilder status(String status) {
            this.status = status;
            return this;
        }
        
        /**
         * Build call for listObservedEvents
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return listObservedEventsCall(limit, cursor, lastReportedAfter, lastReportedBefore, expand, connectionId, errorCode, status, _callback);
        }


        /**
         * Execute listObservedEvents request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            listObservedEventsWithHttpInfo(limit, cursor, lastReportedAfter, lastReportedBefore, expand, connectionId, errorCode, status);
        }

        /**
         * Execute listObservedEvents request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return listObservedEventsWithHttpInfo(limit, cursor, lastReportedAfter, lastReportedBefore, expand, connectionId, errorCode, status);
        }

        /**
         * Execute listObservedEvents request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return listObservedEventsAsync(limit, cursor, lastReportedAfter, lastReportedBefore, expand, connectionId, errorCode, status, _callback);
        }
    }

    /**
     * List Issues
     * List all issues that have been observed by Terminal. Issues are generated when we observe something that may impact the completeness or accuracy of the data we provide but do not justify a full error. For example, if we lack permissions for a specific resource or need to skip an item due to invalid data.
     * @return ListObservedEventsRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public ListObservedEventsRequestBuilder listObservedEvents() throws IllegalArgumentException {
        return new ListObservedEventsRequestBuilder();
    }
    private okhttp3.Call markResolvedCall(String issueId, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/issues/{issueId}/resolve"
            .replace("{" + "issueId" + "}", localVarApiClient.escapeString(issueId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] { "bearerAuth" };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call markResolvedValidateBeforeCall(String issueId, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'issueId' is set
        if (issueId == null) {
            throw new ApiException("Missing the required parameter 'issueId' when calling markResolved(Async)");
        }

        return markResolvedCall(issueId, _callback);

    }


    private ApiResponse<Void> markResolvedWithHttpInfo(String issueId) throws ApiException {
        okhttp3.Call localVarCall = markResolvedValidateBeforeCall(issueId, null);
        return localVarApiClient.execute(localVarCall);
    }

    private okhttp3.Call markResolvedAsync(String issueId, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = markResolvedValidateBeforeCall(issueId, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }

    public class MarkResolvedRequestBuilder {
        private final String issueId;

        private MarkResolvedRequestBuilder(String issueId) {
            this.issueId = issueId;
        }

        /**
         * Build call for markResolved
         * @param _callback ApiCallback API callback
         * @return Call to execute
         * @throws ApiException If fail to serialize the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call buildCall(final ApiCallback _callback) throws ApiException {
            return markResolvedCall(issueId, _callback);
        }


        /**
         * Execute markResolved request
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public void execute() throws ApiException {
            markResolvedWithHttpInfo(issueId);
        }

        /**
         * Execute markResolved request with HTTP info returned
         * @return ApiResponse&lt;Void&gt;
         * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public ApiResponse<Void> executeWithHttpInfo() throws ApiException {
            return markResolvedWithHttpInfo(issueId);
        }

        /**
         * Execute markResolved request (asynchronously)
         * @param _callback The callback to be executed when the API call finishes
         * @return The request call
         * @throws ApiException If fail to process the API call, e.g. serializing the request body object
         * @http.response.details
         <table summary="Response Details" border="1">
            <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
            <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
         </table>
         */
        public okhttp3.Call executeAsync(final ApiCallback<Void> _callback) throws ApiException {
            return markResolvedAsync(issueId, _callback);
        }
    }

    /**
     * Resolve Issue
     * Mark an issue&#39;s status as &#x60;resolved&#x60; until the issue is observed again.
     * @param issueId (Required)  (required)
     * @return MarkResolvedRequestBuilder
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td>  </td><td>  -  </td></tr>
     </table>
     */
    public MarkResolvedRequestBuilder markResolved(String issueId) throws IllegalArgumentException {
        if (issueId == null) throw new IllegalArgumentException("\"issueId\" is required but got null");
            

        return new MarkResolvedRequestBuilder(issueId);
    }
}
